
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using VRC.SDK3.Components;
using System;

#if !COMPILER_UDONSHARP && UNITY_EDITOR
using UnityEditor;
using UdonSharpEditor;
using System.Collections;
using System.Collections.Generic;
using System.IO;
#endif


namespace Emychess
{
    /// <summary>
    /// Behaviour for the chess board
    /// </summary>
    /// <remarks>
    /// Note that the board doesn't actually hold piece positions, that is all handled by the <see cref="Piece"/> class, so that single piece positions can be synced individually, using MUCH less bandwith.
    /// However having a grid representation of the board can be useful for move generation, for that use <see cref="GetBoardGrid"/>
    /// </remarks>
    [UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]
    public class Board : UdonSharpBehaviour
    {
        public VRCObjectPool[] piece_pools;
        public Transform pieces_parent;
        public Material whitePieceMaterial;
        public Material blackPieceMaterial;
        [Tooltip("Material for UI pieces (promotion screen)")]
        public Material ghostMaterial;
        public AudioClip pieceMovedClip;
        public AudioClip pieceCapturedClip;
        public Renderer board_renderer;
        public GameRules.DefaultRules currentRules; //As of right now can't really support multiple game modes, but laying the groundwork for it in the future
        public ChessManager chessManager;

        /// <summary>
        /// Generated by <see cref="_RegenerateGrid"/>, a representation of the board's state in the form of a grid, encoded as an array of 64 <see cref="Piece"/> references, with <see cref="null"/> representing empty spaces
        /// </summary>
        [HideInInspector]
        public Piece[] grid;
        /// <summary>
        /// Used to set indicators on the board shader (for legal moves)
        /// </summary>
        [HideInInspector]
        private float[] IndicatorArray;
        [HideInInspector]
        public Piece whiteKing;
        [HideInInspector]
        public Piece blackKing;
        /// <summary>
        /// A reference to the pawn that did a double push last round, used to check for en passant
        /// </summary>
        [HideInInspector]
        public Piece PawnThatDidADoublePushLastRound;

        //editor only stuff
        [HideInInspector]
        public GameObject[] piecePrefabs;
        [HideInInspector]
        public int[] pieceAmounts;
        
        /// <summary>
        /// Get VRC Object pool that contains pieces of a specific type, to spawn/recall pieces
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public VRCObjectPool GetPool(string type)
        {
            VRCObjectPool foundPool = null;
            foreach (VRCObjectPool pool in piece_pools)
            {
                if (pool.name == type)
                {
                    foundPool = pool;
                }
            }
            return foundPool;
        }
        /// <summary>
        /// Get how many pieces of a specific type can still be spawned
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public int GetPiecesAvailableCount(string type)
        {
            VRCObjectPool pool = GetPool(type);
            int count = 0;
            if (pool == null) { Debug.LogError("Couldn't find pool for type " + type); }
            else
            {
                foreach(GameObject obj in pool.Pool)
                {
                    if (obj.activeSelf == false) count++;
                }
            }
            return count;
        }
        public Piece _SpawnPiece(int x,int y,bool white,string type)
        {
            VRCObjectPool pool = GetPool(type);
            Networking.SetOwner(Networking.LocalPlayer, pool.gameObject);
            GameObject spawnedPiece = pool.TryToSpawn();
            if (spawnedPiece != null)
            {
                Networking.SetOwner(Networking.LocalPlayer, spawnedPiece);
                Piece piece = (Piece)(UdonSharpBehaviour)spawnedPiece.GetComponent(typeof(UdonBehaviour));
                piece._Setup(x, y, white);
                return piece;
            }
            
            return null;
            
        }

        /// <summary>
        /// Checks if the game is over, and returns which kind of game over state it is 
        /// </summary>
        /// <param name="white">Side that is currently playing</param>
        /// <param name="isKingInCheck"></param>
        /// <returns>0 if not over, 1 if checkmate, 2 if stalemate</returns>
        public int _CheckIfGameOver(bool white,bool isKingInCheck)
        {
            bool hasNoLegalMoves = true;
            Piece[] pieces = GetAllPieces();
            if (pieces.Length == 2)
            {
                if ((pieces[0] == whiteKing || pieces[0] == blackKing) && (pieces[1] == whiteKing || pieces[1] == blackKing))
                {
                    return 1;
                }
            }
            foreach(Piece piece in pieces)
            {
                if (piece.white == white)
                {
                    Vector2[] legalMoves = currentRules.GetAllLegalMoves(piece, this);
                    int moveCount = 0;
                    foreach(Vector2 move in legalMoves)
                    {
                        if (move != currentRules.legalMovesIgnoreMarker && move!=currentRules.legalMovesEndMarker)
                        {
                            moveCount++;
                        }
                        if (move == currentRules.legalMovesEndMarker) break; 
                    }
                    if (moveCount != 0) { hasNoLegalMoves = false; break; }
                }
            }
            if (hasNoLegalMoves)
            {
                if(isKingInCheck)
                {
                    return 1;
                }
                else
                {
                    return 2;
                }
            }
            else
            {
                return 0;
            }
        }
        
        /// <summary>
        /// Set pieces of the specified side grabbable if the local player is the specified player, all ungrabbable otherwise
        /// </summary>
        /// <param name="player"></param>
        /// <param name="white">Side for which to make pieces grabbable</param>
        public void _SetPiecesGrabbable(VRCPlayerApi player,bool white)
        {
            if (Networking.LocalPlayer == player)
            {
                foreach(Piece piece in GetAllPieces())
                {
                    bool isGrabbable = (white == piece.white) && chessManager.inProgress;
                    piece.SetGrabbable(isGrabbable);
                }
            }
            else
            {
                _AllPiecesUngrabbable();
            }
        }

        /// <summary>
        /// Make all pieces ungrabbable
        /// </summary>
        public void _AllPiecesUngrabbable()
        {
            foreach(Piece piece in GetAllPieces())
            {
                piece.SetGrabbable(false);
            }
        }
        
        /// <summary>
        /// Capture all pieces, effectively clearing the board
        /// </summary>
        public void _ClearBoard()
        {
            foreach(Piece piece in GetAllPieces())
            {
                piece._Capture();
            }
        }

        /// <summary>
        /// Read a FEN (Forsyth–Edwards Notation) string and set the board accordingly
        /// </summary>
        /// <param name="FEN"></param>
        public void ReadFENString(string FEN) //TODO read FULL FEN notation and also export FEN from grid
        {
            _ClearBoard();
            int x = 0;
            int y = 7;
            string[] substrings = FEN.Split(' ');
            string boardString = substrings[0];
            foreach (char character in boardString)
            {
                switch (character)
                {
                    case ('p'): { _SpawnPiece(x, y, false, "pawn"); x++; break; }
                    case ('P'): { _SpawnPiece(x, y, true, "pawn"); x++; break; }
                    case ('n'): { _SpawnPiece(x, y, false, "knight"); x++; break; }
                    case ('N'): { _SpawnPiece(x, y, true, "knight"); x++; break; }
                    case ('b'): { _SpawnPiece(x, y, false, "bishop"); x++; break; }
                    case ('B'): { _SpawnPiece(x, y, true, "bishop"); x++; break; }
                    case ('r'): { _SpawnPiece(x, y, false, "rook"); x++; break; }
                    case ('R'): { _SpawnPiece(x, y, true, "rook"); x++; break; }
                    case ('q'): { _SpawnPiece(x, y, false, "queen"); x++; break; }
                    case ('Q'): { _SpawnPiece(x, y, true, "queen"); x++; break; }
                    case ('k'): { _SpawnPiece(x, y, false, "king"); x++; break; }
                    case ('K'): { _SpawnPiece(x, y, true, "king"); x++; break; }
                    case ('/'): { x = 0; y--; break; }
                    default:
                        {
                            if (Char.IsDigit(character))
                            {
                                int offset = int.Parse(character.ToString());
                                x += offset;
                                break;
                            }
                            break;
                        }
                }
            }
            if (substrings.Length > 1 && !currentRules.anarchy)
            {
                bool white = substrings[1] == "w" ? true : false;
            }
        }

        /// <summary>
        /// Get how many pieces are currently on the board
        /// </summary>
        /// <returns></returns>
        public int GetPieceCount()
        {
            int count = 0;
            foreach(Transform child in pieces_parent)
            {
                if (child.gameObject.activeSelf) { count++; }
            }
            return count;
        }

        /// <summary>
        /// Get an array of all pieces on the board
        /// </summary>
        /// <returns></returns>
        public Piece[] GetAllPieces()
        {
            Piece[] pieces = new Piece[GetPieceCount()];
            int pieceIndex = 0;
            for(int i = 0; i < pieces_parent.childCount; i++)
            {
                GameObject child = pieces_parent.GetChild(i).gameObject;
                if (child.activeSelf == true)
                {
                    pieces[pieceIndex] = (Piece)(UdonSharpBehaviour)child.GetComponent(typeof(UdonBehaviour));
                    pieceIndex++;
                }
            }
            return pieces;
        }

        /// <summary>
        /// Turn 2D coordinate to an index that can be used to access a board grid
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        public int GridToIndex(int x,int y)
        {
            return x * 8 + y;
        }
        /// <summary>
        /// Turn 2D vector to an index that can be used to access a board grid
        /// </summary>
        /// <param name="vec"></param>
        /// <returns></returns>
        public int VecToIndex(Vector2 vec)
        {
            return (GridToIndex((int)vec.x, (int)vec.y));
        }
        /// <summary>
        /// Check if a coordinate is within the bounds of the board
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        public bool isValidCoordinate(int x,int y)
        {
            return (x >= 0 && x <= 7 && y >= 0 && y <= 7);
        }
        /// <summary>
        /// Set a piece to a certain position in a grid
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="piece"></param>
        /// <param name="grid"></param>
        public void SetGridPiece(int x,int y,Piece piece,Piece[] grid)
        {
            grid[GridToIndex(x, y)] = piece;
        }
        /// <summary>
        /// Get a grid of the current board state
        /// </summary>
        /// <returns>A <see cref="Piece"/> array of length 64, in which empty spaces are represented with <see cref="null"/></returns>
        public Piece[] GetBoardGrid()
        {
            Piece[] grid = new Piece[64];
            Piece[] pieces = GetAllPieces();
            foreach(Piece piece in pieces)
            {
                SetGridPiece(piece.x, piece.y, piece, grid);
            }
            return grid;
            
        }
        /// <summary>
        /// Get the piece at the specified coordinates in a grid
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="grid"></param>
        /// <returns>A <see cref="Piece"/> if the square is not empty, <see cref="null"/> if it is</returns>
        public Piece GetGridPiece(int x,int y,Piece[] grid)
        {
            if (!isValidCoordinate(x, y)) return null;
            return grid[GridToIndex(x, y)];
        }

        /// <summary>
        /// Get a piece at the specified coordinate on the board grid
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns>A <see cref="Piece"/> if the square is not empty, <see cref="null"/> if it is</returns>
        public Piece GetPiece(int x,int y)
        {
            return GetGridPiece(x, y, grid);
        }
        /// <summary>
        /// Simulate a piece's move on a grid, including capture, en passant and castling
        /// </summary>
        /// <param name="ox">Starting x</param>
        /// <param name="oy">Starting y</param>
        /// <param name="tx">Target x</param>
        /// <param name="ty">Target y</param>
        /// <param name="grid"></param>
        public void MoveGridPiece(int ox,int oy,int tx,int ty,Piece[] grid)
        {
            Piece piece = GetGridPiece(ox, oy, grid);
            if (piece.type == "pawn" && ox != tx && GetGridPiece(tx,ty,grid) == null)//EN PASSANT
            {
                int dir = piece.white ? -1 : 1;
                SetGridPiece(tx, ty + dir, null, grid);
            }
            if (piece.type == "king" && Mathf.Abs(tx - ox) == 2)
            {
                int dir = Mathf.Min(tx, ox) == tx ? -1 : 1;
                int rox = dir == 1 ? 7 : 0;
                int roy = oy;
                int rtx = tx + (dir * -1);
                int rty = ty;
                MoveGridPiece(rox, roy, rtx, rty, grid);
            }
            SetGridPiece(tx, ty, piece, grid);
            SetGridPiece(ox, oy, null, grid);
        }
        /// <summary>
        /// Simulate a piece's move on a grid, including capture, en passant and castling
        /// </summary>
        /// <param name="original">Starting position</param>
        /// <param name="target">Target position</param>
        /// <param name="grid"></param>
        public void MoveGridPieceVec(Vector2 original,Vector2 target,Piece[] grid)
        {
            MoveGridPiece((int)original.x, (int)original.y, (int)target.x, (int)target.y, grid);
        }

        /// <summary>
        /// Get a piece on the board at the specified coordinates
        /// </summary>
        /// <param name="pos"></param>
        /// <returns>A <see cref="Piece"/> if the square is not empty, <see cref="null"/> if it is</returns>
        public Piece GetPieceVec(Vector2 pos)
        {
            return GetPiece((int)pos.x, (int)pos.y);
        }
        /// <summary>
        /// Refresh the <see cref="grid"/> based on the current board status
        /// </summary>
        public void _RegenerateGrid()
        {
            grid = GetBoardGrid();
        }

        /// <summary>
        /// Reset the board based on the starting configuration defined in the rules
        /// </summary>
        public void _ResetBoard()
        {
            currentRules.ResetBoard(this);
            _ClearIndicators();
        }

        private void _RefreshIndicators()
        {
            board_renderer.material.SetFloatArray("_Indicators", IndicatorArray);
        }
        /// <summary>
        /// Set an indicator on the board
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="indicatorValue">0 for no indicator, 1 for a move indicator, 2 for a check indicator, 3 for debug indicators</param>
        public void SetIndicator(int x, int y, float indicatorValue)
        {
            IndicatorArray[x * 8 + y] = indicatorValue;
            _RefreshIndicators();
        }
        public void _ClearIndicators()
        {
            IndicatorArray = new float[64];
            _RefreshIndicators();
        }

        /// <summary>
        /// Display debug indicators on the board for every spot on the <see cref="grid"/> that constains a piece
        /// </summary>
        /// <param name="grid"></param>
        public void _DebugGrid(Piece[] grid)
        {
            _ClearIndicators();
            for(int i = 0; i < 64; i++)
            {
                if (grid[i] == null) { IndicatorArray[i] = 0; }
                else { IndicatorArray[i] = 3; }
            }
            _RefreshIndicators();
        }
        /// <summary>
        /// Logs a grid to the console
        /// </summary>
        /// <param name="grid"></param>
        public void _LogGrid(Piece[] grid)
        {
            for(int i = 0; i < 7; i++)
            {
                string logString = "";
                for(int j=0;j<7; j++)
                {
                    Piece currentSquarePiece = grid[GridToIndex(i, j)];
                    logString += (currentSquarePiece == null ? "null" : currentSquarePiece.type)+" ";
                }
                Debug.Log(logString);
            }
        }
        /// <summary>
        /// Logs the <see cref="grid"/>
        /// </summary>
        public void _LogCurrentGrid()
        {
            _LogGrid(grid);
        }


        public void Start()
        {
            _ClearIndicators();
            _RegenerateGrid();
            if (Networking.IsMaster)
            {
                //ResetBoard();
            }
        }


    }

    #if !COMPILER_UDONSHARP && UNITY_EDITOR
    /// <summary>
    /// Inspector for the <see cref="Board"/> behaviour, allows to automatically generate the <see cref="VRCObjectPool"/> objects with the desired number of pieces
    /// </summary>
    [CustomEditor(typeof(Board))]
    public class BoardInspector : Editor
    {
        private SerializedProperty piece_pools;
        private SerializedProperty pieces_parent;
        private SerializedProperty whitePieceMaterial;
        private SerializedProperty blackPieceMaterial;
        private SerializedProperty ghostMaterial;
        private SerializedProperty currentRules;
        private SerializedProperty board_renderer;
        private SerializedProperty pieceMovedClip;
        private SerializedProperty pieceCapturedClip;
        private SerializedProperty chessManager;

        private SerializedProperty piecePrefabs;
        private SerializedProperty pieceAmounts;

        public struct piecePrefabAmount
        {
            public GameObject prefab;
            public int amount;
        }

        private void OnEnable()
        {
            piece_pools = serializedObject.FindProperty(nameof(Board.piece_pools));
            pieces_parent = serializedObject.FindProperty(nameof(Board.pieces_parent));
            whitePieceMaterial = serializedObject.FindProperty(nameof(Board.whitePieceMaterial));
            blackPieceMaterial = serializedObject.FindProperty(nameof(Board.blackPieceMaterial));
            ghostMaterial = serializedObject.FindProperty(nameof(Board.ghostMaterial));
            currentRules = serializedObject.FindProperty(nameof(Board.currentRules));
            board_renderer = serializedObject.FindProperty(nameof(Board.board_renderer));
            pieceMovedClip = serializedObject.FindProperty(nameof(Board.pieceMovedClip));
            pieceCapturedClip = serializedObject.FindProperty(nameof(Board.pieceCapturedClip));
            chessManager = serializedObject.FindProperty(nameof(Board.chessManager));


            piecePrefabs = serializedObject.FindProperty(nameof(Board.piecePrefabs));
            pieceAmounts = serializedObject.FindProperty(nameof(Board.pieceAmounts));

            Board board = (Board)target;
            if (board.pieceAmounts == null || board.pieceAmounts.Length < 6) { board.pieceAmounts = new[] { 16, 8, 2, 8, 16, 8 }; }
            if (board.piecePrefabs == null || board.piecePrefabs.Length < 6) { board.piecePrefabs = new GameObject[6]; }
        }

        public Dictionary<string,piecePrefabAmount> GetPieceDictionary(Board board)
        {
            Dictionary<string, piecePrefabAmount>  pieceDict = new Dictionary<string, piecePrefabAmount>();
            pieceDict["pawn"] = new piecePrefabAmount { prefab = board.piecePrefabs[0], amount = board.pieceAmounts[0] };
            pieceDict["bishop"] = new piecePrefabAmount { prefab = board.piecePrefabs[1], amount = board.pieceAmounts[1] };
            pieceDict["king"] = new piecePrefabAmount { prefab = board.piecePrefabs[2], amount = board.pieceAmounts[2] };
            pieceDict["knight"] = new piecePrefabAmount { prefab = board.piecePrefabs[3], amount = board.pieceAmounts[3] };
            pieceDict["queen"] = new piecePrefabAmount { prefab = board.piecePrefabs[4], amount = board.pieceAmounts[4] };
            pieceDict["rook"] = new piecePrefabAmount { prefab = board.piecePrefabs[5], amount = board.pieceAmounts[5] };
            return pieceDict;
        }

        public void GeneratePools(Board board, Dictionary<string, piecePrefabAmount> pieceDict=null)
        {
            
            if (pieceDict == null)
            {
                pieceDict = GetPieceDictionary(board);

            }
            foreach (VRCObjectPool pool in board.piece_pools)
            {
                for (int i = pool.transform.childCount; i > 0; i--)
                {
                    DestroyImmediate(pool.transform.GetChild(0).gameObject);
                }
                piecePrefabAmount ppa = pieceDict[pool.name];
                pool.Pool = new GameObject[ppa.amount];

                for (int i = 0; i < ppa.amount; i++)
                {
                    GameObject spawned = (GameObject)PrefabUtility.InstantiatePrefab(ppa.prefab, pool.transform);
                    //PrefabUtility.UnpackPrefabInstance(spawned,PrefabUnpackMode.Completely,InteractionMode.AutomatedAction);
                    spawned.name = pool.name + i;
                    pool.Pool[i] = spawned;
                    Piece piece = spawned.GetUdonSharpComponent<Piece>();
                    piece.UpdateProxy();
                    piece.board = board;
                    piece.type = pool.name;
                    piece.pool = pool;
                    piece.ApplyProxyModifications();
                    spawned.SetActive(false);
                    UnityEditor.EditorUtility.SetDirty(spawned);
                }
                UnityEditor.EditorUtility.SetDirty(pool);
                
            }
            UnityEditor.EditorUtility.SetDirty(PrefabUtility.GetOutermostPrefabInstanceRoot(board.gameObject));
            //PrefabUtility.ApplyPrefabInstance(PrefabUtility.GetOutermostPrefabInstanceRoot(board.gameObject), InteractionMode.AutomatedAction);
            Debug.Log("[EmyChess]: Pools succesfully generated");
        }
        public void ResetPools(Board board)
        {
            foreach (VRCObjectPool pool in board.piece_pools)
            {
                for (int i = pool.transform.childCount; i > 0; i--)
                {
                    DestroyImmediate(pool.transform.GetChild(0).gameObject);
                }
                pool.Pool = null;
            }
            Debug.Log("[EmyChess]: Pools succesfully resetted",board);
        }

        public override void OnInspectorGUI()
        {
            if (UdonSharpGUI.DrawDefaultUdonSharpBehaviourHeader(target)) return;

            Board board = (Board)target;

            EditorGUI.BeginChangeCheck();
            EditorGUILayout.PropertyField(pieces_parent);
            EditorGUILayout.PropertyField(whitePieceMaterial);
            EditorGUILayout.PropertyField(blackPieceMaterial);
            EditorGUILayout.PropertyField(ghostMaterial);
            EditorGUILayout.PropertyField(board_renderer);
            EditorGUILayout.PropertyField(pieceMovedClip);
            EditorGUILayout.PropertyField(pieceCapturedClip);
            EditorGUILayout.PropertyField(chessManager);

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Rules Object (currently only supports default, do not switch)");
            EditorGUILayout.PropertyField(currentRules);

            EditorGUILayout.Space();
            EditorGUILayout.PropertyField(piece_pools, new GUIContent("Piece Pools"), true);


            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Piece Prefabs");
            int i = 0;
            foreach (KeyValuePair<string,piecePrefabAmount> keyValue in GetPieceDictionary(board))
            {
                string name = keyValue.Key;
                EditorGUILayout.LabelField(char.ToUpper(name[0]) + name.Substring(1));
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.PropertyField(piecePrefabs.GetArrayElementAtIndex(i), GUIContent.none);
                EditorGUILayout.PropertyField(pieceAmounts.GetArrayElementAtIndex(i), GUIContent.none);
                GUILayout.FlexibleSpace();
                EditorGUILayout.EndHorizontal();
                i++;
            }


            if (EditorGUI.EndChangeCheck())
            {
                serializedObject.ApplyModifiedProperties();

            }

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("WARNING, generating/resetting pools doesn't work on prefab instances");
            EditorGUILayout.LabelField("Unpack the prefab FIRST or run inside the prefab");

            if (GUILayout.Button("Generate Pools"))
            {
                if (PrefabUtility.GetPrefabInstanceStatus(board.piece_pools[0].gameObject) != PrefabInstanceStatus.NotAPrefab)
                {
                    Debug.LogError("Pools are in a prefab instance, unpack FIRST or run inside the prefab instead",board);
                }
                else
                {
                    GeneratePools(board);
                }
                
            }

            if(GUILayout.Button("Reset Pools"))
            {
                if (PrefabUtility.GetPrefabInstanceStatus(board.piece_pools[0].gameObject) != PrefabInstanceStatus.NotAPrefab)
                {
                    Debug.LogError("Pools are in a prefab instance, unpack FIRST or run inside the prefab instead", board);
                }
                else
                {
                    ResetPools(board);
                }
            }
        
        }
    }
    #endif
}